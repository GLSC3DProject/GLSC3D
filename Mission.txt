2023.07.04

Slack で有料プランの無料トライアルを用いて復元したもの：

GLSC3Dテスト向け仮インストール手順です
・適当なフォルダでターミナルを開き，下記のコマンドを順に実行する

git clone -b metal https://github.com/GLSC3DProject/GLSC3D/
cd GLSC3D
mkdir Build
cd Build
cmake ..
make -j8

・ホームディレクトリ直下のlibフォルダに，リポジトリ内のOut/libglsc3d_3.aを適当な名前にリネームしてコピーまたはシンボリックリンクする
・glsc3d_3.h, glsc3d_3_math.hは，少し変更していますが，新旧どちらのバージョンでも動くはずです
・ホームディレクトリ直下にglsc3d_runtimeフォルダを作り，NotoSansCJKjp-Regular.otf (Install_file_and_script_and_fontsフォルダ内) とshaders.metallib (Shadersフォルダ内) をコピーまたはシンボリックリンクする
・Install_file_and_script_and_fontsフォルダ内のccg_metalスクリプト内のlibglsc3d_3.aを上で指定した名前に変更する
・ccg_metalを使用してプログラムをコンパイルする

なおccg_metalの中を見ていただくと分かりますが，Cのときに-lc++オプションを付けています
MetalはCからは利用できず，C++からmetal-cppライブラリ経由で利用していますが，metal-cpp内部で-lc++が必要なのだと思われます

既知の問題としてccg_metalでコンパイルすると僕の環境では

object file (/Users/kazuma/lib/libglsc3d_3.a(g_area.cpp.o)) was built for newer macOS version (12.6) than being linked (12.0)

などの警告が出ます
cmakeとccで別のOSバージョン指定になっていると思われますが詳細は不明です


2次元モードにおいては現時点では点，線，三角形の総数は2の24乗を上限とさせていただきました
これは深度バッファの実効的な精度が24ビットであると思われることと，これより多くの図形を描くことは実行速度の面からも現実的でないと思われるため，実装を簡単にするためにこのような制約を設定させていただきました
2の24乗=16,777,216は4Kのピクセル数3840x2160=8,294,400より多いため，一般的なディスプレイでは表示しきれないくらいの情報量です
5K(5120x2880=14,745,600)よりも多いです
何か不都合がありましたらご連絡ください


あとg_sleepにおけるイベント処理の見直しを行い，引数が正の値のとき，スリープ中のキーボード/マウス入力は復帰時に確認できるようにしました


"object file (...) was built for newer macOS version ..." のメッセージについての解決方法を調べてみましたが，具体的なバージョン (12.0 など) を指定する以外の解決方法は見つかりませんでした
なにかいいアイディアはありますかね？単に無視するということでも良い気はしますが
ちなみにこの警告は前から出てましたか？

----------------------------------------------------
2022.12.14

Metal 対応版 GLSC3D 開発者用ドキュメント

glsc3d_3_private.h 内の G_USE_METAL の定義によって Metal 対応が有効化される．(Mac OS のみ，デフォルト)
それが無効のとき，G_USE_OPENGL_CORE_PROFILE の定義によってモダン OpenGL が使用される．(デフォルト)
Metal とモダン OpenGL で共有できるコードも多いため，
これらのどちらかが定義されていると自動的に G_USE_VERTEX_BUFFERS が定義されてこれも条件分岐に使用される．

G_DISPLAY_DEBUG_MESSAGES を有効化するとウインドウタイトルにデバッグ用メッセージが表示される．

G_USE_RELATIVE_RUNTIME_PATH を有効化するとフォントとシェーダーファイルは相対パスによって指定される．
(テスト用：システムに GLSC3D をインストールせずにサンプルコードを動作させたいときに使用する)

Metal では OpenGL とは異なり，描画は非同期的に実行されるため，バッファーの使い回しと相性が良くない．
その対策として，頂点データは Metal のバッファーは使用せずに setVertexBytes 関数によって直接転送される．
(これがあらゆる環境で意図した通りに機能するかは要検証)
また，文字列は文字列専用のレイヤーに描画され，最後に一回だけ合成される．
その結果として，文字列は描画順にかかわらず常に図形より手前に表示されるように仕様が変更されている．

----------------------------------------------------
2019.12.22

文字描画を高速化するため，文字列描画のための一時的なバッファ G_TEXT_RENDERING_BUFFER クラスを作成した．
FreeType は 1 文字ずつしか描画できないためここにいったん保存してからまとめて OpenGL に渡す．
文字列の高さは描画開始時点でわかっているが，幅は描画終了時点までわからないため，
高さ方向に連続的なメモリ配置を使用する (描画時にシェーダーで xy を反転する)

----------------------------------------------------
2019.08.30

GLSC3D 開発者用ドキュメント (GLSC3D 3.0.1 時点)

OpenGL 3.1以降，Vertex Buffer と Programmable Shader の使用が必須となった．

Vertex Buffer は CPU 上の配列データを GPU に転送して描画に使用するためのものである．
ソースファイル g_vertex_buffer.cpp は，Vertex Buffer の機能を提供するためのものである．

列挙型 G_PRIMITIVE_MODE は，点（マーカー），線，三角形，または “未定義” のどれかを表す．

g_begin_points, g_begin_lines, g_begin_triangles 関数が glBegin 関数のように使用できるようにしている．
これらは g_set_primitive_mode 関数を呼んでいる．

glVertex 関数に対応するのは，g_vertex_buffer_append 関数 (3D三角形の時),
または g_emit_point, g_emit_line, g_emit_triangle 関数 (それ以外の時)である．
glEnd 関数に対応する関数はない．描画命令は必要に応じて g_vertex_buffer_flush 関数により発行される(後述)．

グローバル変数 g_primitive_mode は，現在の描画モードを保存している．
これは最初に “未定義” で初期化され，g_set_primitive_mode 関数で変更される．
これは関数 g_prepare_[points, lines, triangles] を呼び出して，
マーカーの種類やサイズの座標系，2Dか3Dかに基づいてシェーダーの設定をするが，
効率化のため g_primitive_mode に変化がないときは処理をスキップするため，
必要に応じて g_reset_primitive_mode 関数で g_primitive_mode を “未定義” に戻す．

GLSC3D 3.0.1 では，マーカーと線と三角形の描画が混ざった場合の高速化のため，別々の配列に保存するようにしている．

描画命令は次の関数が呼ばれた場合に g_vertex_buffer_flush 関数により発行される．
・g_sel_scale
・g_boundary
・g_finish
・g_text_standard
・g_text_2D_virtual
・g_text_3D_virtual
・g_marker_type
・g_line_type
また，次の場合にも発行される．
・マーカーの大きさの座標系が変更されたとき (g_marker_size/g_marker_radius)
・点，線，三角形用の配列のどれかが一杯になったとき

----------------------------------------------------
日付不明．
g_cylinder関数の挙動を確認する．(解決)
g_box_2Dとg_box_3Dを旧仕様も提供する．(解決)
2Dにおいて，点・線・面などの描画命令は逐次実行するようにする．(解決)
g_circleなどに内部と辺を塗りつぶすように分岐させる．(解決)
g_cameraの提供をする？（フルの引数のバージョンよ構造体のバージョンを提供する）(保留)
仮想座標系の枠を描く関数(g_region_boundary)を追加する．(解決)
g_captureでJPGを吐き出すようにする．(保留)
モダン OpenGL への対応 (解決)
g_isosurface.cのコードを書き直す >>> 秋山先生の仕事

マニュアルのミッション
Sample_g_line の実行結果のスクリーンショットを修正する (解決)
覚書のファイル構成を修正する

----------------------------------------------------

2017/11/19
1. g_text_virtual_2D >>> g_text_2D_virtual マニュアル内変更 >>> OK
2. マニュアルでリンク >>> OK
3. Windowsバージョンの調整
4. macのwarningを消す >>> Akiyama
5. g_data_plot
6. 添え字 上付き 下付き
7. gmail メーリングリスト >>> OK
8. config デフォルト値の設定

・fortran問題
・線のクオリティーを上げる
・g_data_plot_2dの右端問題
・g_def_are_2Dとg_def_are_3Dはg_def_areaに統一すべき？
・g_polygon_2Dで星型
・描画エリアと描画枠の言葉の統一
・しすいたいなどの絵を載せる．
・g_rectangle_3Dをアップデートする．
・g_rectangle_2Dを新設する．
・g_cuboid_3Dを新設

GLSC3Dに関する覚書：重要な案件は
1. 固定座標系の扱い（マニュアルの書き方）：固定座標系で描くのか
　固定座標系に一致する自由座標系で描くのか
2. マーカーを2Dと3Dに分けるか（2Dマーカーの充実）
3. g_ellipse, g_cuboid（新関数）における向きの指定法（SO(3) の元の表現）
4. 2次元オブジェクトを3次元空間に置く時の向きの指定法

----------------------------------------------------
